\documentclass[a4paper, notitlepage]{report}
\usepackage{graphicx}

\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{listings}

\setlength{\parskip}{1em}

\usepackage{titlesec, color}
\usepackage[Lenny]{fncychap}


%% \usepackage[T1]{fontenc}
%% \usepackage{titlesec, blindtext, color}
%% \definecolor{gray75}{gray}{0.75}
%% \newcommand{\hsp}{\hspace{20pt}}
%% \titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}



\usepackage{etoolbox}

\renewcommand{\paragraph}[1]{\vspace*{1em}\noindent\textbf{#1}\hspace*{1em}}

\lstset{
  breaklines=true,
  basicstyle=\ttfamily,
  numbers=left
}

\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}

\title{Evaluating the Cryptol Language for Cryptography}
\author{Zhiyuan Lin}
\date{\today}



\begin{document}

%{\let\newpage\relax\maketitle}
\maketitle
\begin{abstract}

  Implementing reliable cryptographic protocols is a difficult task, and
  the Cryptol language is an attempt at using programming language to
  improve reliability of cryptographic implementations. The language
  provides interesting features such as a powerful type system, and
  native support for formal verification. In this study we evaluate
  Cryptol through the combination of a literature survey and an implementation
  project. We conclude that Cryptol language is well suited for
  cryptography, although it still has a long way to go to become a practical
  language. 
  
\end{abstract}

\newpage

\tableofcontents

\newpage


\chapter{Introduction}

Cryptographic protocols are used everywhere nowadays. Google, for example,
recently claimed in its transparency report that 75\% of the requests to
its servers are now encrypted.
However, providing secure implementations of cryptographic algorithms
remains a difficult task, even for experienced security engineers and
researchers.
Cryptographic algorithms often involve a lot of advanced number theory.
Without a proper understanding of the background theory it is difficult to implement
protocols with the necessary level of precision and precaution.
Simple mistakes such as failing to validate input, or reusing keys could
compromise the security of the entire system.
Moreover, recent cryptographic algorithms are often only specified in
academic publications, which by nature focus on the background theory and security
proofs of the protocols, instead of implementation details.
Even if the protocol follows the specification, the system must still be secured
against side-channel attacks.
There are also human factors that might affect security of cryptographic protocols.
An secure protocol when used improperly could also result in leakage of information.
With all these potential issues to be resolved, it is no wonder why
many existing implementations of cryptographic protocols have or had known
vulnerabilities.
OpenSSL, one of the most widely-used implementation of SSL and
TLS protocols, still suffer from constant criticism and had famous bugs such as
Heartbleed.

There have been many studies on improving the reliability of cryptographic
implementations. Some try to tackle the problem from a programming language
perspective.
These studies propose that instead of using traditional languages such as
C and C++, which offers little guarantees to the program, we should create high-level,
performant programming languages
that are dedicated to the subject of cryptography.
Among these attempts, the Cryptol programming language is a good example with
a unique combination of features. 

Cryptol is a pure functional programming language with native support for
formal verification, and it is designed specifically to be the language of
cryptography. With these unique features, it would be interesting to see if
the language delivers on its promises. That is exactly the purpose of this
project: to investigate and evaluate the Cryptol programming language.
This study provides insight on whether new programming languages can serve
as useful tools for enhancing cryptographic implementation, and what language
features are important for cryptography.
We discuss our approach and contributions below.

\paragraph{Organization and Contributions}

This project involves two major components. The first part of the project
is a literature survey, presented in Chapter~\ref{chap:survey}.
We introduce the essential features such as the type system of the Cryptol language
and the theory behind its formal verification utilities in this chapter.
Furthermore, we cover other domain specific languages and related tools for
cryptography extensively and compare these languages with Cryptol.
This part of the project not only serves as the foundation for further discussion,
but also gives an overview of the field of languages for cryptography.

In the section part of the project, we evaluate the Cryptol programming language
by implementing and verifying the AES algorithm. This includes implementing the
algorithm in a functional style, and devising properties that can be proved
for the implementation. We also summarize the experience of using Cryptol
and provide constructive feedback on the features of Cryptol. Combined with the survey,
this gives us a comprehensive evaluation of the Cryptol language.
This part of the results are discussed in Chapter~\ref{chap:implementation}.

Finally in Chapter~\ref{chap:conclusion} we summarize the study and discuss
ideas for future developments.




\newpage
\chapter{Literature Survey}
\label{chap:survey}

In this chapter we present previous researches that uses programming
language as a means to improve reliability of cryptographic applications.

We start with a detailed introduction to the essential features and
design objectives of the Cryptol language in Section~\ref{sec:cryptol},
followed by a comprehensive survey of related works that use programming
language to improve reliability of cryptographic implementation in
Section~\ref{sec:crypto_lang}.

\section{The Cryptol Language}
\label{sec:cryptol}

As has been mentioned before, Cryptol is a high-level programming language
designed for cryptography. It provides a formal methods-based approach
to cryptographic developments.

The Cryptol language is designed with several objectives in mind:

\begin{itemize}
\item Cryptol is designed to be the standard language of cryptography
\item The Cryptol language provides high assurance of the correctness
of the implementation
\item The Cryptol source program can be used as source for code generation
to multiple target platforms
\end{itemize} 

We introduce the features that bring about these benefits in detail below.

%\paragraph{The Standard Language of Cryptography}
\subsection{The Standard Language of Cryptography}

Cryptol is ambitiously designed to become the standard language of cryptography.
Implementation of cryptographic algorithms in Cryptol are expected to serve as 
a high-level formal specification or at least reference implementation 
of the algorithms.
This means that the language allows for algorithms specified in academic
papers and standards to be translated into Cryptol source code in a manner that
is straightforward and readable.
Moreover, Cryptol frees developers from machine level details
so that they could focus on developing new algorithms.

To achieve this goal, Cryptol is designed to be a pure functional programming
language similar to Haskell. The Cryptol syntax, just like Haskell's, is
heavily inspired by mathematical notations, and therefore can express computations
in cryptographic protocols easily.
It is also argued that functional programs
are usually shorter and easier to understand.
The persistent data structures provided in Cryptol
allows for easier analysis and optimization of computation. Furthermore,
the functional style naturally helps to create simple and clean abstractions so
that the program is well-structured. 

\subsection{High Assurance Programming}

To serve as authoritative specifications, Cryptol programs need
to be correct first. Cryptol comes with several features that provide strong
guarantee of the correctness of functions:
\begin{itemize}
\item Type System
\item Formal Verification 
\item Automated Testing
\end{itemize}

\paragraph{Type System}

Cryptol uses a type system based on the Hindley-Milner
type system~\cite{hindley1969principal}, extend with size-polymorphism
and arithmetic type predicates~\cite{lewis2003cryptol}. The type system
is designed to capture constraints that naturally arise from cryptographic
algorithms such as fixed-size keys and input blocks.

\begin{figure}
\begin{lstlisting}[frame=single]
encrypt: {n} (0 < n, n < 3) => [8*n] -> [8*n]
\end{lstlisting}
\caption{Cryptol Type Signature}
\label{fig:type}
\end{figure}

See Figure~\ref{fig:type} for an example of type signatures in Cryptol.
The signature specifies a function \emph{encrypt} that takes as input
an 8-bit or 16-bit integer and output a number of the same size.
The quantified type variable \emph{n} in the type signature are bounded
by the predicates $ 0 < n$ and $n < 3$. The predicates put a limit on the
values of the type variable. Any arithmetic operations can be used in
such predicates.
Type signatures of these kinds rule out a large number of illegal input
statically and provides strong guarantee to the correctness of the program.
The AES algorithm~\cite{standard2001announcing} for example operates on 128, 192
or 256-bit keys. Such a constraint can precisely specified and checked in
Cryptol type system.

\paragraph{Formal Verification and Automated Testing}

The Cryptol language provides native formal verification utilities designed for
equivalence and safety-checking. Correctness properties can be specified in Cryptol
as part of the source code accompanying the algorithm. The Cryptol checker then
checks for correctness of properties by means of SAT/SMT solvers. The Z3 prover is used
by default.

Figure~\ref{fig:property} shows a correctness property defined in Cryptol. The
property states simply that decryption after encryption with the same key should
result in the original message. We can see that a correctness property in Cryptol
is but another function that returns a Bit (boolean) type value.

The Cryptol language provides an interactive mode similar to Haskell's with which
developers can test functions interactively.
Cryptol can conduct verification of the above property automatically with a simple
\emph{:prove} command issued in its interactive prompt, as shown in Figure~\ref{fig:prove}.

\begin{figure}
  \begin{lstlisting} [frame=single]
    encrypt: {n} [8] -> String n -> String n
    // implementation of encryption
    
    decrypt: {n} [8] -> String n -> String n
    // implementation of decryption

    encryptCorrect: {n} [8] -> String n -> Bit
    property encryptCorrect =
             decrypt key (encrypt key msg) == msg 
  \end{lstlisting}
  
  \caption{Correctness Property in Cryptol}
  \label{fig:property}
\end{figure}

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :prove encryptCorrect
    >> Q.E.D
  \end{lstlisting}
  \caption{Proving Correctness Properties in Cryptol}
  \label{fig:prove}
\end{figure}

In cases where the property is invalid, the Cryptol checker provides an input
for which the property does not hold true as counterexample. This gives developers
a concrete scenario to look into and debug.

Because Cryptol properties are just functions, it is possible to write conditions
in the property to construct proofs efficiently for more restricted scenarios.
For polymorphic functions, we can also restrict its type signatures when
proving properties.

Of course it is possible that external theorem prover used by Cryptol could
not finish the proof within a reasonable amount of time. Therefore Cryptol
also provides another command \emph{:check} that can be used in the same way
as \emph{:prove} to conducted automated testing on the property. Figure~\ref{fig:test}
demonstrates how this utility can be used in Cryptol.

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :set tests=10000
       // setting number of test cases generated 
    >> :check encryptCorrect
  \end{lstlisting}
  \caption{Testing Correctness Properties in Cryptol}
  \label{fig:test}
\end{figure}

Similar to proving correctness, we can check in Cryptol whether a property is
satisfiable through the \emph{:sat} command. The command finds a satisfying input
for the property using an off-the-shelf SAT solver. 
Finding satisfying assignments are interesting in cryptography because it can
be used to formulate attacks to the cryptographic protocol. Figure~\ref{fig:sat}
provides an example of known plain-text attacks specified in Cryptol.
Such a property would certainly have a satisfying assignment. The point, however,
is that Cryptol should never be able to find that assignment in a feasible amount
of time in order for the encryption function to be safe.

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :sat (\key -> encrypt key msg == cipher)
  \end{lstlisting}
  \caption{Known Plaintext Attack in Cryptol}
  \label{fig:sat}
\end{figure}

\subsection{How Formal Verification Works in Cryptol}

Under the hood, the Cryptol source is translated to a \emph{symbolic bit-vector} language,
for which there are existing methods that can then decide if the code segments satisfies
a certain property. Translation is done through symbolic evaluation, i.e.
by executing the function in question with symbolic variables.

The symbolic bit-vector program can be reduced to a SAT (boolean satisfiability)
instance and solved with an
off-the-shelf SAT solver such as \emph{lingeling}. For checking equivalence property
such as the one in Figure~\ref{fig:property}, we ask the SAT solver if there exists
an assignment that would make the property return 0 (false). If there is, then the
property does not hold, and part of the assignment will be translated to an input
and returned as counterexample for the property. The SAT-based property checking
approach has been used to prove equivalence of Cryptol program before and after
compiler optimization~\cite{erkok2009pragmatic}.

Cryptol also supports using SMT (satisfiability modulo theory)
solvers in place of SAT solvers to decide the
bit-vector programs. The reason why SMT solvers might be better than SAT solvers
in this case is that they tend to natively support higher-level structural information
and arithmetic operations better than SAT solvers. Many SMT solvers come with dedicated
mode for bit-vector programs. In practice, it was found that SMT solvers work better
when proving properties that involve algebraic equalities.



\section{Languages for Cryptographic Applications}
\label{sec:crypto_lang}

The idea of using language features to enhance cryptographic applications 
have been investigated for over a decade. Some studies, such 
as \cite{akinyele2013charm} builds upon existing languages, and provides
extensions, e.g. libraries and frameworks, for efficient implementation 
of cryptographic protocols. 
Other like Cryptol~\cite{lewis2003cryptol} create brand-new domain specific 
programming languages dedicated to cryptographic applications. These
works also focus on different aspects of implementation. Some focus
on reliability and correctness guarantees, while others emphasize ease 
of use and performance.

There exist languages that are designed for specific kinds of security protocols.
ZKPDL~\cite{meiklejohn2010zkpdl}, for example, is an interpreted description language 
for specifying zero-knowledge protocols, motivated by applications such
as electronic cash. Although the language is designed specifically for
implementing prover and verifier of zero-knowledge, the language itself 
also have potentials for specifying other types of privacy-preserving 
systems. The ZKPDL interpreter also performs optimizations for protocols.

Similar to ZKPDL, TASTY~\cite{henecka2010tasty} is a novel compiler
designed specifically for generating efficient two-party computation
protocols. TASTY provides a high-level domain specific language in which
the user can specify the computation to be performed on encrypted data, 
and the compiler would translate that directly to a secure protocol.
Moreover, TASTY uses the FairPlay~\cite{malkhi2004fairplay} system to
evaluate the protocol generated.

On the language extension side,
NaCl~\cite{bernstein2012security} is a C/C++ library for implementing 
cryptographic protocols that 
provides security guarantees through features such as no data flow from 
secrets to load address, and no padding oracles.
Charm~\cite{akinyele2013charm}
is an extensible framework in Python 
designed for rapid prototyping of cryptographic schemes. Charm promotes
modularity and re-usability of cryptographic primitives, and successfully 
increases interoperability of existing numeric libraries such Sage and
the Stanford Pairing-Based Crypto (PBC). It also provides benchmarking
and profiling utilities for determining the performance of cryptographic
algorithms.

The Ceritified computer-aided cryptography~\cite{almeida2013certified} 
project provides a computer-aided framework for proving concrete security for
 cryptographic implementations. It extends EasyCrypt, an interactive framework
for verifying the security of cryptographic applications, to
provide formal verification for cryptographic applications implemented 
in a C-like language. The framework also supports generation of 
optimized machine code based on the high-level language while
retaining the security properties.

The Cryptol language has a close relative named
${\mu}Cryptol$~\cite{shields2006language,pike2006verifying}
The language focuses on providing a verifying compiler that proves the correctness
of the code transformation process.
Agosta et al.~\cite{agosta2007domain} also proposed a domain specific language
for cryptography based on Python. The major benefit that this work provides,
however, is syntactic.


One of the strongest competitor for Cryptol is 
CAO~\cite{moss2010bridging}, a language designed to facilitate high-level,
performant implementation of the AES algorithm. The CAO compiler utilizes
advanced techniques to improve performance of the implementation, but 
provides no specific functions for verifying the correctness of the algorithm.
There are separate studies on verifying CAO programs such as~\cite{barbosa2010deductive},
however the features are not included as a part of the language.

cPLC~\cite{bangerter2011cplc} is a more recent attempt at providing a domain
specific languages for cryptography. Instead of borrowing the syntax of existing
programming languages, cPLC provides a language that is closed to the 
mathematical notations used in the cryptography community to describe 
protocols. Moreover cPLC provides native support for mathematical entities
and operations such as groups that are often used in cryptography.

An important feature of Cryptol is that it provides native support for formal
verification of cryptographic protocols,
a subject that have been studied for decades.
We refer to~\cite{meadows1994formal} for these works.
 

\paragraph{Comparing Cryptol with Other Cryptographic Languages}

Figure~\ref{fig:compare} compares Cryptol with CAO and cPLC, two of the languages we have
covered in Section~\ref{sec:crypto_lang}. These two languages are chosen because,
like Cryptol, they focus on cryptographic applications in general. As shown in the
table, Cryptol is the only one that employs a functional programming style, and
also the only one that facilitates formal verification. The other two languages,
although both high-level languages, put a strong focus on performance of the
implementations.

\begin{figure}
  \begin{center}
    \begin{tabular}{|l | p{0.2\linewidth} | p{0.6\linewidth} |}
      \hline
      Language & Programming Paradigm & Features \\
      \hline
      Cryptol & Purely Functional  & high-level specification, formal verification \\
      \hline
      CAO~\cite{moss2010bridging} & Imperative & high-level specification, performance \\
      \hline
      cPLC~\cite{bangerter2011cplc} & Imperative & high-level specification, mathematical syntax, numerical libraries \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Comparing Cryptographic Programming Languages}
  \label{fig:compare}
\end{figure}



\newpage

\chapter{Implementation and Evaluation}
\label{chap:implementation}

This section presents the implementation part of the project. For the purpose of
empirically evaluating the Cryptol language in practice, we created an implementation
of the AES algorithm and devised properties to verify the implementation.
The AES algorithm is the current standard of symmetric key
encryption and is well specified in~\cite{standard2001announcing}. A brief introduction
to the algorithm and the implementation is provided in Section~\ref{sec:aes}.
The correctness properties and results of verification is discussed in
Section~\ref{sec:correct}. In Section~\ref{sec:review} we summarize the observations
of the language from the implementation process. 

\section{The AES Algorithm}
\label{sec:aes}

We start by providing a brief introduction to the AES algorithm in the section
to facilitate our discuss of the implementation.

As a block cipher, the AES
algorithm runs on a $4 \times 4$ column-major order matrix of bytes.
The matrix is formally called a \emph{state} and it has a fixed size of 128 bits.
See Figure~\ref{fig:state} for an example of states.

\begin{figure}
  \begin{center}
    \begin{equation}
      \begin{bmatrix}
        b_0 & b_4 & b_8 & b_{12} \\
        b_1 & b_5 & b_9 & b_{13} \\
        b_2 & b_6 & b_{10} & b_{14} \\
        b_3 & b_7 & b_{11} & b_{15} 
      \end{bmatrix}
    \end{equation}
  \end{center}
  \caption{A State in AES}
  \label{fig:state}
\end{figure}

The other input that the algorithm takes is the encryption key, which can be 128, 192,
or 256-bit long. In AES, a sequence of substitution and permutation steps are repeated
for a number of rounds, and the number of rounds is decided by the key size.
For 128-bit keys, 10 rounds of repetition is required, whereas 12 and 14 rounds are
needed for 192-bit and 256-bit keys respectively. The number of rounds are needed
to use the encryption key efficiently. More specifically, the algorithm does not
simply reuse the encryption key for every round of operations. Instead, the key is
expanded into (\emph{number of rounds } + 1) round keys, each of which is 128 bits. 
The expansion
is done using Rijndael's key schedule. This way a different round key is used in
each round and there is no repetition. Note that because each entry in the state
matrix is one byte, most arithmetic operations in Cryptol are defined over a finite
field $GF(2^8)$ (GF stands for Galois Field).

In brief there are 5 major functions used in AES:
\begin{itemize}
\item \emph{KeyExpansion}: for expanding encryption key to round keys, as we have
  discussed before.
\item \emph{AddRoundKey}: Applying round key to the state using bitwise \emph{xor}.
\item \emph{SubBytes}: Substituting each byte in the state according to a lookup table
  called the S-box.
\item \emph{ShiftRows}: Shifting the last three rows of the state cyclically each by
  different number of bytes.
\item \emph{MixColumns}: Transform each column (treated as a polynomial on the field
  $GF(2^8)$) through matrix multiplication.
\end{itemize}


\begin{algorithm}
  \caption{The AES Algorithm}
  \label{alg:aes}
  \begin{algorithmic}[1]
    \State roundKeys = expandKey(key)
    \State 
    \Comment{roundKeys is an $n+1$ array where $n$ is the number of rounds.}
    \State state = addRoundkey(state, roundKeys[0])

    \For{i = $1$ to $n-1$ where $n$ is the number of rounds}
    \State state = subBytes(state)
    \State state = shiftRows(state)
    \State state = mixColumns(state)
    \State state = addRoundKey(state, roundKeys[i])
    \EndFor

    \State state = subBytes(state)
    \State state = shiftRows(state)
    \State state = addRoundKey(state, roundKeys[n])
    \State \Comment{The last round does not involve the MixColumns operation.}

    \State \Return state
    
  \end{algorithmic}
\end{algorithm}


We refer to~\cite{standard2001announcing} for more detailed description of these
operations. Algorithm~\ref{alg:aes} shows the pseudo-code for the algorithm using
the operations
introduced.
The decryption function is simply the reverse of the encryption function, and
is made up of operations and rounds that reverse the operations and rounds of
the encryption function.


\section{Implementation Techniques}

% techniques

We present below a few language features that are prominently used in our
implementation.

\paragraph{Type Synonyms}

Remember that size of input is specified in the type signature.
In Cryptol, we can define type synonyms to improve re-usability and readability,
just like in Haskell.
The major data structures in AES are defined as type synonyms in Cryptol in our
implementation.
Remember that a State in Cryptol is a $4 \times 4$ matrix of bytes. An example
of the State type is shown in Figure~\ref{fig:typedef}. 

\begin{figure}
  \begin{lstlisting}[frame=single]
    type State = [4][4][8]
  \end{lstlisting}
  \caption{Defining the State type in Cryptol}
  \label{fig:typedef}
\end{figure}


\paragraph{Fold}

As a functional programming language, Cryptol provides no supports for writing
for-loop or
while-loop. The only natural way of writing a loop in Cryptol, besides recursive
functions is \emph{fold}.
In functional programming, fold is a way to recursively analyze a data structure
such as a list, combine the results of each iteration and accumulatively build up
a return value.
See Figure~\ref{fig:fold} for an example of loops written with \emph{fold} in
Cryptol.
This is a function that computes the sum of the list \emph{xs}.
Note that the variable \emph{ys} is used in its in own definition.
This is similar to a \emph{foldr} function in Haskell~\cite{lipovaca2011learn}.
The result, however, in this case is a list that includes the value of each
intermediate step.

\begin{figure}
  \begin{lstlisting}[frame=single]
    xs = [1 .. 10] // a list of numbers
    ys = [0] # [ y + x | x <- xs 
                       | y <- ys ]
    // ys = [0, 1, 3, ..., 55]
  \end{lstlisting}
  \caption{A Loop Written in Fold in Cryptol}
  \label{fig:fold}
\end{figure}

Folds are the recommended way of writing loops in Cryptol, and therefore are
frequently used in our implementation.

% list of functions

\section{Implementation and Verification}
\label{sec:correct}

Using a pure functional language such as Cryptol to implement the AES algorithm,
fortunately does not result in any complications more than necessary. Each major
operation can be implemented as a pure function, i.e. one that is free of side
effects, and of course the eventual encryption and decryption functions are also
side-effect free.

In Figure~\ref{fig:functions} we list type signatures of the major functions
in AES. This provides a high-level overview of our implementation. Note how
well this corresponds to the description of AES in Section~\ref{sec:aes}.
All the major operations transform the \emph{State} type. The encryption and decryption
functions work on 128-bit plain text, and takes as input a key that is either
128, 192, or 256-bit long. Of course these are not the only functions and types in
the implementation. There are many more helper functions such as those for computing
multiplicative inverse on a finite field and for matrix multiplication.
We also implement multiple versions of the same function where possible, so that
these different versions can be used to verify each other. This is conducted
under the assumption that with the correct specification, the same mistake is
unlikely to be made in two different versions.

\begin{figure}
  \begin{lstlisting}[frame=single]
    type State = [4][4][8]
    type RoundKey = State
    type KeySize = 128    // 192, 256

    // encryption functions
    subBytes : State -> State
    shiftRows: State -> State
    mixColumns: State -> State
    addRoundKey: RoundKey -> State -> State
    encrypt: [128] -> [KeySize] -> [128]

    // decryption functions
    reverseSubBytes: State -> State
    reverseShiftRows: State -> State
    reverseMixColumns: State -> State
    decrypt: [128] -> [KeySize] -> [128]
    
  \end{lstlisting}
  \caption{Function Signatures of Major AES Operations}
  \label{fig:functions}
\end{figure}

The next step  is naturally verifying our implementation.
This is however not as straight-forward as the example shown in
Figure~\ref{fig:property}, because high-level properties defined directly over
the encryption and decryption functions generally take too long to prove.
This is likely because the AES algorithm has an intentionally large state space,
and the purpose of the algorithm is to obfuscate and make it computationally impossible
to analyze the relationship between the input and the output.
Therefore instead of verifying the encryption and decryption functions as a whole,
we adopt a different strategy: verify each component of the algorithm separately.
As the composition of components is pretty straight-forward for AES, this approach
would provide strong guarantee that the implementation is correct.

A set of correctness properties are defined in order to verify the implementation.
These properties for functions are designed using the three strategies:
\begin{itemize}
\item Verifying important properties intrinsic to the functions;
\item Verifying equivalence of different versions of the same function;
\item Verifying that the reverse functions successfully undo the encrypt functions
\end{itemize} 

Many of the basic functions have important properties that can be used to verify
them, and many of these properties can be proved efficiently. For example, the
product of a number and its multiplicative inverse on a finite field equals to 1.
This property is the defining characteristic of multiplicative inverse and can be used
to verify the function. Similarly we verify commutativity and associativity for
finite field multiplication.

Moreover, the AES specification sometimes provide optimization such as look-up table
that replaces computation steps. We implement some of these optimizations and
ask Cryptol to check equivalence of the optimized and original functions. This is
the approach taken for functions such as \emph{subBytes}.

Another way to ensure correctness is make sure that reverse operations used in the
decryption function can actually cancel out their corresponding operations in
the encryption function. This is approach is used to verify \emph{shiftRows} for
example.

In complement with formal verification, we use the automated testing utility
provided in Cryptol to test the properties that are defined, especially when the
properties could not be proved in a feasible amount of time.

Figure~\ref{fig:properties} summarizes the result of the formal verification process.
The result is largely positive: most of the properties can be efficiently proved,
while the rest passed the automated tests at least. This gives us a strong confidence
that the implementation is correct.

\begin{figure}
  \begin{center}
    \begin{tabular}{|p{0.25\linewidth} | p{0.5\linewidth} | p{0.15\linewidth} |}
      \hline
      Property & Description & Result \\
      \hline
      \emph{polySelfAdd} & the sum of two same polynomials on $GF(2^*)$ is 0
      & proved \\
      \hline
      \emph{mulIden} & any number multiplied with the identity element over
      the field equals the number itself & proved \\
      \hline
      \emph{mulCommutative} & commutative property of field multiplication
      & proved \\
      \hline
      \emph{mulAssociate} & associative property of field multiplication
      & proved \\
      \hline
      \emph{mulInverseCorrect} & multiplicative inverse's definition
      & proved \\
      \hline
      \emph{subByteCorrect} & two versions of subBytes are equivalent
      & proved \\
      \hline
      \emph{shiftRowsCorrect} & \emph{shiftRows} applied 4 times results in the original state
      & proved \\
      \hline
      \emph{rConCorrect} & two versions of round constants are equivalent
      & tested \\
      \hline
      \emph{formByteCorrect} & verify \emph{formByte} against its reverse function
      & proved \\
      \hline
      \emph{toFromStateCorrect} &  toState is the reverse of fromState
      & proved \\
      \hline
      \emph{reverseShiftRows} & verify \emph{shiftRows} against its reverse function
      & proved \\
      \hline
      \emph{mixColumnsCorrect} & verify \emph{mixColumns} against its reverse function
      & tested \\
      \hline
      \emph{aesCorrect} & decrypt (encrypt (m, k), k) == m
      & tested \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Correctness Properties and Results of Verification}
  \label{fig:properties}
\end{figure}

The program is implemented and verified using Cryptol 2.2.6 on
Ubuntu 16.04.
For instructions on installing Cryptol and running the source code,
please refer to the \emph{README.md} included in the project.

\section{Review of the Cryptol Language}
\label{sec:review}

In this section we summarize our observations of the Cryptol language from the both
 the literature survey and the implementation project. 

First of all, Cryptol is a very unique solution to programming language for cryptography.
As we have seen in Section~\ref{sec:crypto_lang}, it is not the only language that have
been designed specifically for cryptography. However Cryptol is the only pure functional
language that has been proposed. Moreover, its native support for formal verification is
also unique. These features all make it stand out as a programming language for 
cryptography.

Specifying correctness properties in Cryptol is easy as the properties are eventually
just functions. Verification is reasonably fast for most basic functions. 
The precise type system also provides very good compiler-time guarantees: if the program 
compiles, it can probably run without errors.

The language also naturally promotes modularity and readability.
The implementation of the AES algorithm in Cryptol, even after including multiple 
versions of some functions, are still shorter than the equivalent implementation
in C or Java. The size of the source code could be reduced even more should it be
 desired. This however is not the purpose of the project, and therefore not attempted.
The functional programming style works well for encryption and decryption algorithms
as they are often by design pure functions.

However as a relative young language, there are still a few caveats with the language.
We discuss these issue below.

\paragraph{Proving Polymorphic Properties}

Cryptol does not support verifying properties with polymorphic types, because the 
properties might hold for some type instances but not others. This however doesn't mean
polymorphic types are useless in properties. It is just that when asking Cryptol
to prove these properties, the developers must provide extra, monomorphic type
signature for the prover to work.

\paragraph{Branching}

The if statement is often the only solution to writing conditions in Cryptol. 
The advantage of this is that the
algorithms specified in an imperative style can often be translated with ease. However,
whether this is a good language feature is a matter of debate. The language does
provide pattern matching, however it is not as powerful as that in Haskell, and is
used to only access components of data structures.
A more powerful pattern matching feature like that of Haskell's is desirable.

\paragraph{Lack of Support for Floating Point Number}

Cryptol has no native support for floating-point number. This is in fact not a big 
problem for many cryptographic algorithms, especially symmetric key cryptographic
algorithms, as they operate primarily on integers defined over finite fields. 
However floating-point number can be useful when experimenting on advanced
public key cryptographic algorithms, e.g. those using elliptic curves.

\paragraph{Limited Standard Library}

As a language designed for cryptography, Cryptol's standard library lacks functions 
that are common and useful for many cryptographic algorithms. 
During the implementation project, it was often necessary to implement basic functions
that are often seen in cryptography.
Arithmetic operations 
(addition, multiplication, exponentiation, etc.) on finite fields is one example. 
The cPLC~\cite{bangerter2011cplc} language, for example, comes with support for a number
 of mathematical functions that are useful for developing cryptographic algorithms.
With rapid prototyping being one of the design objectives of the Cryptol language, 
it would be a good idea to include basic number theoretical utilities in the 
standard library.

\newpage
\chapter{Conclusion and Future Works}
\label{chap:conclusion}
% The plan has been realized successfully without hiccups.
% Followed the schedules. 

In the project proposal we set out a concrete time frame for the project.
The project adhered to the schedule closely, and everything 
that was planned in the proposal, including both the literature survey and 
the implementation was completed on time.
A large number of properties that were devised were successfully proved on
the implementation. The rest also passed the automated tests at least.

More importantly, the project provides valuable insight to the language itself.
From the survey
and implementation we came to the conclusion that Cryptol is a plausible language 
for cryptography.
The language allows for very high-level specification of algorithms.
The native support for formal verification is very useful
for development of cryptographic algortihms. The precise type system is also 
helpful. However there are still issues, such as the lack of a comprehensive standard 
library, to be resolved for the language to gain traction. 

As a relatively young language, Cryptol has a lot of potential to be developed. 
One of the possibility discussed in~\cite{lewis2003cryptol} is that of compiling 
the Cryptol source code into target languages and platforms such as C, Java, or
even assembly. This however is not supported in the current version of Cryptol.
The Software Analysis Workbench (SAW), a tool developed by the same
organization Galois Inc., also provides utility for proving equivalence of Cryptol 
functions and Java or C functions. 
Similar to Cryptol's property prover. SAW utilizes symbolic execution to
translate programs into formal models.
This means that the Cryptol implementation of an algorithm can be used to verify 
implementations in other languages. It is however not as easy as it sounds, 
as the equivalence checking is only possible when the function design (type signature
etc.)
is similar in these language. That is not necessarily the case as Cryptol
is a functional language, whereas C and Java are imperative, and object-oriented.
Therefore whether the SAW toolset can be used to effectively verify C and Java source
code is a matter to be investigated.

It should also be noted that even if a cryptographic algorithm is proved
to be correct based on a certain 
specification, it still does
not mean that the algorithm is secure. 
At the moment, there is no way to prove security in Cryptol, 
which is not an actual problem of the language. 
Automated proof for security is a hard problem with no general solution, 
especially when there are many different notions of security such as 
IND-CPA (indistinguishability under chosen plaintext attack) and 
IND-CCA (indistinguishability under chosen ciphertext attack).
This is simply something for developers to keep in mind, and can perhaps
be an interesting topic of research.


\newpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
