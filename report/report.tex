\documentclass[a4paper, notitlepage]{report}
\usepackage{graphicx}

\usepackage{subcaption}
\usepackage{hyperref}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{amsmath}
\usepackage{listings}

\setlength{\parskip}{1em}

\usepackage{titlesec, color}
\usepackage[Lenny]{fncychap}


%% \usepackage[T1]{fontenc}
%% \usepackage{titlesec, blindtext, color}
%% \definecolor{gray75}{gray}{0.75}
%% \newcommand{\hsp}{\hspace{20pt}}
%% \titleformat{\chapter}[hang]{\Huge\bfseries}{\thechapter\hsp\textcolor{gray75}{|}\hsp}{0pt}{\Huge\bfseries}



\usepackage{etoolbox}

\renewcommand{\paragraph}[1]{\vspace*{1em}\noindent\textbf{#1}\hspace*{1em}}

\lstset{
  breaklines=true,
  basicstyle=\ttfamily,
  numbers=left
}

\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}

\title{Cryptol: A Domain Specific Language for  Verification of Cryptographic Algorithms}
\author{Zhiyuan Lin}
\date{\today}



\begin{document}

%{\let\newpage\relax\maketitle}
\maketitle
\begin{abstract}

\end{abstract}

\newpage

\tableofcontents

\newpage


\chapter{Introduction}

The aim of this project is to investigate domain specific languages
that enhance reliability of cryptographic algorithms. The focus of this
work is on Cryptol, however other languages with similar facilities will
also be covered as related works.

\begin{figure}[h]
  \centering
\begin{tabular}{| l | p{5cm} |}
  \hline
  May 25th - June 2nd: & Surveying Cyptol and similar languages \\
  \hline
  June 2nd - June 9th: & In-depth investigation of Cryptol's design and theory \\
  \hline
  June 9th - June 23rd: & Implementing AES algorithm in Cryptol \\
  \hline
  June 23rd - July 30th: & Verification of implementaion using Cryptol and SAW. \\
  \hline
  July 30th - July 7th: & Finishing up evaluation and writing report \\
  \hline
  July 7th - July 14th: & Preparing for presentation \\
  \hline
\end{tabular}
\caption{Time Line of The Project}
\label{fig:time}
\end{figure}


Therefore the first part of the project will be a brief survey of Cryptol
and similar languages. This part will also cover high-level design of
the Cryptol language and theory behind its functions for formal verification.

The second part of the project will be empirical study of the Cryptol language
with an implementation.
For the implementation part, the AES symmetric-key algorithm
\cite{standard2001announcing, bertoni2002efficient} is to be implemented
 and properties related to the algorithm will be defined and checked
in Cryptol to evaluate whether the language can efficiently verify
the implementation. AES is chosen because it is the modern standard
for symmetric-key encryption is widely used. 
The focus in this part is the evaluation of the language,
rather than actual implementation of the algorithm, therefore other
algorithms written in Cryptol, if available, will
also be used to conduct empirical evaluations.

Another tool provided as a part of the Cryptol project is called
The Software Analysis Workbench (SAW). SAW also provides formal verification
for properties of programs written in Cryptol.
SAW utilizes symbolic execution to translate programs into formal models.
This tool will also be used to verify the AES implementation in Cryptol
in order to see if it provides better functionalities for verification.

Figure~\ref{fig:time} provides a time frame for the project. This is just
a rough estimation, but the project will follow the steps specified.
As mentioned before, because the focus is investigation
of the Cryptol language, more time will be spent on evaluating the language
functionalities. 


\section{Organizations}

\newpage
\chapter{Literature Survey}

In this chapter we present previous works that uses programming
language as a means to improve reliability of cryptographic applications.
In Section~\ref{sec:crypto_lang}, we give broad overview of several different
works, whereas in Section~\ref{sec:cryptol} we dig into the details of
the Cryptol programming language and the guarantees it provides.

\section{Languages for Cryptographic Applications}
\label{sec:crypto_lang}

The idea of using language features to enhance cryptogprahic applications 
have been investigated for over a decade. Some works, such 
as \cite{akinyele2013charm} builds upon existing languages, and provides
extensions, e.g. libraries and frameworks, for efficient implementation 
of cryptographic protocols. 
Other studies~\cite{lewis2003cryptol} create brand-new domain specific 
programming languages dedicated to cryptographic applications. These
works also focus on different aspects of implementation. Some focus
on relaibility and correctness guarantees, while others emphasize ease 
of use and performance.

Charm~\cite{akinyele2013charm} is an extensible framework in Python 
designed for rapid prototyping of cryptographic schemes. Charm promotes
modularity and reusability of cryptographic primitives, and successfully 
increases inter-operability of existing numeric libraries such Sage and
the Stanford Pairing-Based Crypto (PBC). It also provides benchmarking
and profiling utilities for determining the performance of cryptographic
algorithms.

NaCl~\cite{bernstein2012security} is a C/C++ library for implementing 
cryptographic protocols that 
provides security guarantee through features such as no data flow from 
secrets to load address, and no padding oracles. 

ZKPDL~\cite{meiklejohn2010zkpdl} is an interpreted description language 
for specifying zero-knowledge protocols, motivated by applications such
as electronic cash. Although the language is designed specifically for
implementing prover and verifer of zero-knowledge, the language itself 
also have potentials for specifying other types of privacy-preserving 
systems. The ZKPDL interpreter also performs optimizations for protocols.

Similar to ZKPDL, TASTY~\cite{henecka2010tasty} is a novel compiler
designed specifically for generating efficient two-party computation
protocols. TASTY provides a high-level domain specific language in which
the user can specify the computation to be performed on encrypted data, 
and the compiler would translate that directly to a secure protocol.
Moreover, TASTY uses the FairPlay~\cite{malkhi2004fairplay} system to
evaluate the protocol generated.

The Ceritified computer-aided cryptography~\cite{almeida2013certified} 
project provides a computer-aided framework for proving concrete security for
 cryptogprahic implementations. It extends EasyCrypt, an interative framework
for verifying the security of cryptographic applications, to
provide formal verification for cryptographic applications implemented 
in a C-like language. The framework also supports generation of 
optimized machine code based on the high-level language while
retaining the security properties.

One of the study that is perhaps closest to Cryptol is 
CAO~\cite{moss2010bridging}, a language designed to facilitate high-level,
performant implementation of the AES algorithm. The CAO compiler utilises
advanced techniques to improve performance of the implementation, but 
provides no specific functions for verifying the correctness of the algorithm.
Agosta et al.~\cite{agosta2007domain} also proposed a domain specific language
for cryptography based on Python. The major benefit that this work provides,
however, is syntactic.

cPLC~\cite{bangerter2011cplc} is a more recent attempt at providing a domain
specific languages for cryptogprahy. Instead of borrowing the syntax of existing
programming languages, cPLC provides a language that is closed to the 
mathematical notations used in the cryptography community to describe 
protocols. Moreover cPLC provides native support for mathematical entities
and operations such as groups that are often used in cryptography.

${\mu}Cryptol$~\cite{shields2006language,pike2006verifying} is a language
 derived from Cryptol. The 
study focuses providing a verifying compiler that proves the correctness
of the code tranformation process.

Cryptol applies techniques for formal verification of cryptographic protocols,
a subject that have been studied for decades. We refer to~\cite{meadows1994formal} for these works.

\section{The Cryptol Language}
\label{sec:cryptol}

As has been mentioned before, Cryptol is a high-level programming language
designed for cryptogpraphy. It provides a formal methods-based approach
to cryptographic developments.

The Cryptol language offers several benefits to development of cryptographic
protocols:
\begin{itemize}
\item Cryptol is designed to be the standard language of cryptography
\item The Cryptol language provides high assurance of the correctness
of the implementation
\item The Cryptol source program can be used as source for code generation
to multiple target platforms
\end{itemize} 

We introduce the features that bring about these benefits in detail below.

%\paragraph{The Standard Language of Cryptography}
\subsection{The Standard Language of Cryptography}

Cryptol is ambitiously designed to become the standard language of cryptography.
Implementation of cryptographic algorithms in Cryptol are expected to serve as 
a high-level formal specification or at least reference implementation 
of the algorithms.
This means that the language allows for algorithms specified in academic
papers and standards to be translated into Cryptol source code in a manner that
is straightforward and readable.
Moreover, Cryptol frees developers from machine level detail
so that they could focus on developing new algorithms.

To achieve this goal, Cryptol is designed to be a pure functional programming
language similar to Haskell. The Cryptol syntax, just like Haskell's, is
heavily inspired mathematical notations, and therefore can express computations
in cryptographical protocols easily.
It is also argued that functional programs
are usually shorter and easier to understand.
The persistent data structures provided in Cryptol
allows for easier analysis and optimization of computation. Furthermore,
the functional style naturally helps to create simple and clean abstractions so
that the program is well-structured. 

\subsection{High Assurance Programming}

To serve as authoritative specifications, Cryptol programs need
to be correct first. Cryptol comes with several features that provides strong
guarantees of correctness of functions:
\begin{itemize}
\item Type System
\item Formal Verification 
\item Automated Testing
\end{itemize}

\paragraph{Type System}

Cryptol uses a type system based on the Hindley-Milner
type system~\cite{hindley1969principal}, extend with size-polymorphism
and arithmetic type predicates~\cite{lewis2003cryptol}. The type system
is designed capture constraints that naturally arise from cryptographic
algorithms such as fixed-size keys and input blocks.

\begin{figure}
\begin{lstlisting}[frame=single]
encrypt: {n} (0 < n, n < 3) => [8*n] -> [8*n]
\end{lstlisting}
\caption{Cryptol Type Signature}
\label{fig:type}
\end{figure}

See Figure~\ref{fig:type} for an example of type signatures in Cryptol.
The signature specifies a function \emph{encrypt} that takes as input
an 8-bit or 16-bit integer and output a number of the same size.
The quantified type variable \emph{n} in the type signature are bounded
by the predicates $ 0 < n$ and $n < 3$. The predicates put a limit on the
values of the type variable. Any arithmetic operations can be used in
such predicates.
Type signatures of these kinds rule out a large number of illegal input
statically and provides strong guarantees to the correctness of the program.
The AES algorithm~\cite{standard2001announcing} for example operates on 128, 192
or 256-bit keys. Such a constraint can precisely specified and checked in
Cryptol type system.

\paragraph{Formal Verification and Automated Testing}

The Cryptol language provides native formal verification utilities designed for
equivalence and safety-checking. Correctness properties can be specified in Cryptol
as part of the source code accompanying the algorithm. The Cryptol checker then
checks for correctness of property with the SAT/SMT solvers. The Z3 prover is used
by default.

Figure~\ref{fig:property} shows a correctness property defined in Cryptol. The
property states simply that decryption after encryption with the same key should
result in the original message. We can see that a correctness property in Cryptol
is but another function that returns a Bit (boolean) type value.

The Cryptol language provides an interactive mode similar to Haskell's with which
developers can test functions interactively.
Cryptol can conduct verification of the above property automatically with a simple
\emph{:prove} command issued in its interative prompt, as shown in Figure~\ref{fig:prove}.

\begin{figure}
  \begin{lstlisting} [frame=single]
    encrypt: {n} [8] -> String n -> String n
    // implementation of encryption
    
    decrypt: {n} [8] -> String n -> String n
    // implementation of decryption

    encryptCorrect: {n} [8] -> String n -> Bit
    property encryptCorrect =
             decrypt key (encrypt key msg) == msg 
  \end{lstlisting}
  
  \caption{Correctness Property in Cryptol}
  \label{fig:property}
\end{figure}

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :prove encryptCorrect
    >> Q.E.D
  \end{lstlisting}
  \caption{Proving Correctness Properties in Cryptol}
  \label{fig:prove}
\end{figure}

In cases where the property is invalid, the Cryptol checker provides an input
for which the property does not hold true as counterexample. This gives developers
a concrete scenario to look into and debug.

Because Cryptol properties are just functions, it is possible to write conditions
in the property to construct proofs efficiently for more restricted scenarios.
For polymorphic functions, we can also restrict its type signatures when
proving properties.

Of course it is possible that external theorem prover used by Cryptol could
not finish the proof within a reasonable amount of time. Therefore Cryptol
also provides another command \emph{:check} that can be used in the same way
as \emph{:prove} to conducted automated testing on the property. Figure~\ref{fig:test}
demonstrates how this utility can be used in Cryptol.

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :set tests=10000
       // setting number of test cases generated 
    >> :check encryptCorrect
  \end{lstlisting}
  \caption{Testing Correctness Properties in Cryptol}
  \label{fig:test}
\end{figure}

Similar to proving correctness, we can check in Cryptol whether a property is
satisfiable through the \emph{:sat} command. The command finds a satisfying input
for the property using an off-the-shelf SAT solver. 
Finding satisfying assignments are interesting in cryptography because it can
be used to formulate attacks to the cryptographic protocol. Figure~\ref{fig:sat}
provides an example of known plaintext attacks specified in Cryptol.
Such a property would certainly have a satisfying assignment. The point, however,
is that Cryptol should never be able to find that assignment in a feasible amount
of time in order for the encryption function to be safe.

\begin{figure}
  \begin{lstlisting}[frame=single]
    >> :sat (\key -> encrypt key msg == cipher)
  \end{lstlisting}
  \caption{Known Plaintext Attack in Cryptol}
  \label{fig:sat}
\end{figure}

\section{How Formal Verification Works in Cryptol}

Under the hood, the Cryptol source is translated to a \emph{symbolic bit-vector} language,
for which there are existing methods that can the decide if the code segments satisfies
a certain property. Translation is done through symbolic evaluation,
by executing the function in question with symbolic variables.

The symbolic bit-vector program can be reduced to a SAT (boolean satisfiability)
instance and solved with an
off-the-shelf SAT solver such as \emph{lingeling}. For checking equivalence property
such as the one in Figure~\ref{fig:property}, we ask the SAT solver if there exists
an assignment that would make the property return 0 (false). If there is, then the
property does not hold, and part of the assignment will be translated to an input
and returned as counterexample for the property. The SAT-based property checking
approach has been used to prove equivalence of Cryptol program before and after
compiler optimization~\cite{erkok2009pragmatic}.

Cryptol also supports using SMT (satisfiability modulo theory)
solvers in place of SAT solvers to decide the
bit-vector programs. The reason why SMT solvers might be better than SAT solvers
in this case is that they tend to natively support higher-level structural information
and arithmetic operations better than SAT solvers. Many SMT solvers come with dedicated
mode for bit-vector programs. In practice, it was found that SMT solvers work better
when proving properties that involve algebraic equalities.


\section{Comparing Cryptol with Other Cryptographic Languages}

Figure~\ref{fig:compare} compares Cryptol with CAO and cPLC, the languages we have
covered in Section~\ref{sec:crypto_lang}. These two languages are chosen because,
like Cryptol, they focus on cryptographic applications in general. As shown in the
table, Cryptol is the only when that employs a functional programming style, and
also the only one that faciliates formal verification. The other two languages,
although both high-level languages, put a strong focus on performance of the
implementations.

\begin{figure}
  \begin{center}
    \begin{tabular}{|l | p{0.2\linewidth} | p{0.6\linewidth} |}
      \hline
      Language & Programming Paradigm & Features \\
      \hline
      Cryptol & Purely Functional  & high-level specification, formal verification \\
      \hline
      CAO~\cite{moss2010bridging} & Imperative & high-level specification, performance \\
      \hline
      cPLC~\cite{bangerter2011cplc} & Imperative & high-level specification, mathematical syntax, numerical libraries \\
      \hline
    \end{tabular}
  \end{center}
  \caption{Comparing Cryptographic Programming Languages}
  \label{fig:compare}
\end{figure}



\newpage

\chapter{Implementation and Evaluation}

This section presents the implementation part of the project. For the purpose of
empirically evaluating the Cryptol language in practice, we created an implementation
of the AES algorithm and devised properties to verify the implementation.
The AES algorithm is the current standard of symmetric key
encryption and is well specified in~\cite{standard2001announcing}. A brief introduction
to the algorithm and the implementation is provided in Section~\ref{sec:aes}.
The correctness properties and results of verification is dicussed in
Section~\ref{sec:correct}. In Section~\ref{sec:review} we summarize the observations
of the language from the implementation process. 

\section{The AES Algorithm}
\label{sec:aes}

We provide a brief introduction to the AES algorithm in the section to faciliate our
discuss of the implementation. 

\section{Proving Correctness of the AES algorithm}
\label{sec:correct}
% The plan has been realized successfully without hiccups.
% Followed the schedules. 

\section{Review of the Cryptol Language}
\label{sec:review}


\newpage
\chapter{Conclusion and Future Works}



\newpage

\bibliographystyle{ieeetr}
\bibliography{report}

\end{document}
